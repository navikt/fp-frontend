var b=Object.defineProperty;var F=(e,n,t)=>n in e?b(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var o=(e,n,t)=>(F(e,typeof n!="symbol"?n+"":n,t),t);import{r as s}from"./index-6d8bab86.js";import{j as f}from"./index.es-4b9ea889.js";var c=(e=>(e.NOT_STARTED="NOT_STARTED",e.LOADING="LOADING",e.SUCCESS="SUCCESS",e.ERROR="ERROR",e))(c||{});const D={},O=s.createContext(D),V=s.createContext(void 0),q=({children:e,initialState:n})=>{const[t,a]=s.useReducer((i,r)=>{switch(r.type){case"success":return{...i,[r.key]:r.data};case"remove":return Object.keys(i).filter(d=>d!==r.key).reduce((d,l)=>({...d,[l]:i[l]}),{});default:throw new Error}},n||D);return f.jsx(O.Provider,{value:t,children:f.jsx(V.Provider,{value:a,children:e})})};try{q.displayName="RestApiProvider",q.__docgenInfo={description:`Håndterer state for data som skal hentes fra backend kun en gang og som en trenger aksess til
mange steder i applikasjonen.`,displayName:"RestApiProvider",props:{initialState:{defaultValue:null,description:"",name:"initialState",required:!1,type:{name:"{ [x: string]: any; }"}}}}}catch{}const T={errors:[]},I=s.createContext(T),U=s.createContext(void 0),A=({children:e,initialState:n})=>{const[t,a]=s.useReducer((i,r)=>{switch(r.type){case"add":return{errors:i.errors.concat(r.data)};case"remove":return T;default:throw new Error}},n||T);return f.jsx(I.Provider,{value:t,children:f.jsx(U.Provider,{value:a,children:e})})};try{A.displayName="RestApiErrorProvider",A.__docgenInfo={description:"Tilbyr kontekst for lagring av feilmeldinger.",displayName:"RestApiErrorProvider",props:{initialState:{defaultValue:null,description:"",name:"initialState",required:!1,type:{name:"State"}}}}}catch{}const L=()=>s.useContext(I).errors;try{L.displayName="useRestApiError",L.__docgenInfo={description:`Hook som henter alle feilmeldinger registrert i kontekst.
Fungerer kun i komponenter som har en`,displayName:"useRestApiError",props:{}}}catch{}const N=()=>{const e=s.useContext(U),n=s.useCallback(a=>{e&&e({type:"add",data:a})},[]),t=s.useCallback(()=>{e&&e({type:"remove"})},[]);return{addErrorMessage:n,removeErrorMessages:t}};try{N.displayName="useRestApiErrorDispatcher",N.__docgenInfo={description:`Hook som tilbyr funksjoner for å legge til eller fjerne feil i kontekst.
Fungerer kun i komponenter som har en`,displayName:"useRestApiErrorDispatcher",props:{}}}catch{}var m=(e=>(e.POLLING_HALTED_OR_DELAYED="POLLING_HALTED_OR_DELAYED",e.POLLING_TIMEOUT="POLLING_TIMEOUT",e.REQUEST_ERROR="REQUEST_ERROR",e.REQUEST_FINISHED="REQUEST_FINISHED",e.REQUEST_FORBIDDEN="REQUEST_FORBIDDEN",e.REQUEST_STARTED="REQUEST_STARTED",e.REQUEST_UNAUTHORIZED="REQUEST_UNAUTHORIZED",e.STATUS_REQUEST_FINISHED="STATUS_REQUEST_FINISHED",e.STATUS_REQUEST_STARTED="STATUS_REQUEST_STARTED",e.UPDATE_POLLING_MESSAGE="UPDATE_POLLING_MESSAGE",e.REQUEST_GATEWAY_TIMEOUT_OR_NOT_FOUND="REQUEST_GATEWAY_TIMEOUT_OR_NOT_FOUND",e))(m||{}),R=(e=>(e.PENDING="PENDING",e.COMPLETE="COMPLETE",e.DELAYED="DELAYED",e.CANCELLED="CANCELLED",e.HALTED="HALTED",e))(R||{});class H extends Error{constructor(t){super("Maximum polling attempts exceeded");o(this,"location");this.location=t}}var w=(e=>(e.MANGLER_TILGANG_FEIL="MANGLER_TILGANG_FEIL",e.TOMT_RESULTAT_FEIL="TOMT_RESULTAT_FEIL",e.BEHANDLING_ENDRET_FEIL="BEHANDLING_ENDRET_FEIL",e.GENERELL_FEIL="GENERELL_FEIL",e))(w||{});const Q=["MANGLER_TILGANG_FEIL"],j=e=>e&&e.response&&e.response.data?e.response.data:e,ie=(e,n)=>!!n&&j(n).type===e,Y=e=>!!e&&Q.some(n=>n===e),P=e=>typeof e=="string",B=e=>{var n;return e&&((n=e.config)==null?void 0:n.responseType)==="blob"},$=e=>{const n=new FileReader;return new Promise((t,a)=>{n.onerror=()=>{n.abort(),a(new Error("Problem parsing blob"))},n.onload=()=>{n.result&&!(n.result instanceof ArrayBuffer)?t(n.result):a(new Error("Problem parsing blob"))},e instanceof Blob&&n.readAsText(e)})};class z{constructor(n,t){o(this,"notify");o(this,"isPollingRequest");o(this,"handleError",async n=>{if(n instanceof H){this.notify(m.POLLING_TIMEOUT,{location:n.location});return}const t=this.formatError(n);if(B(n)){const a=await $(t.data);P(a)&&(t.data=JSON.parse(a))}t.isGatewayTimeoutOrNotFound?this.notify(m.REQUEST_GATEWAY_TIMEOUT_OR_NOT_FOUND,{location:t.location},this.isPollingRequest):t.isUnauthorized?this.notify(m.REQUEST_UNAUTHORIZED,{message:n.message},this.isPollingRequest):t.isForbidden?this.notify(m.REQUEST_FORBIDDEN,t.data?t.data:{message:n.message}):t.is418?this.notify(m.POLLING_HALTED_OR_DELAYED,t.data):!n.response&&n.message?this.notify(m.REQUEST_ERROR,{message:n.message},this.isPollingRequest):Y(t.type)||this.notify(m.REQUEST_ERROR,this.getFormattedData(t.data),this.isPollingRequest)});o(this,"getFormattedData",n=>P(n)?{message:n}:n);o(this,"findErrorData",n=>n.data?n.data:n.statusText);o(this,"formatError",n=>{const t=n&&n.response?n.response:void 0;return{data:t?this.findErrorData(t):void 0,type:t&&t.data?t.data.type:void 0,status:t?t.status:void 0,isForbidden:t?t.status===403:void 0,isUnauthorized:t?t.status===401:void 0,is418:t?t.status===418:void 0,isGatewayTimeoutOrNotFound:t?t.status===504||t.status===404:void 0,location:t&&t.config?t.config.url:void 0}});this.notify=n,this.isPollingRequest=t}}const W=202,Z=50,E="INTERNAL_CANCELLATION",J=e=>new Promise(n=>{setTimeout(n,e)}),X=e=>!!(e!=null&&e.location)&&(e.status===R.DELAYED||e.status===R.HALTED);class re{constructor(n,t,a,i){o(this,"httpClientApi");o(this,"restMethod");o(this,"path");o(this,"config");o(this,"maxPollingLimit",Z);o(this,"notify",()=>{});o(this,"isCancelled",!1);o(this,"isPollingRequest",!1);o(this,"setNotificationEmitter",n=>{this.notify=n});o(this,"execLongPolling",async(n,t=0,a=0)=>{if(a===this.maxPollingLimit)throw this.notify(m.REQUEST_FINISHED),new H(n||"No location");const i=a<30?t:t+(a-30)*t;if(await J(i),!n||this.isCancelled)return null;this.notify(m.STATUS_REQUEST_STARTED);const r=await this.httpClientApi.get(n);if(this.notify(m.STATUS_REQUEST_FINISHED),!("data"in r))return r;const d=r.data;if(d&&d.status===R.PENDING){const{pollIntervalMillis:l,message:u}=d;return this.notify(m.UPDATE_POLLING_MESSAGE,u),this.execLongPolling(n,l,a+1)}return r});o(this,"execute",async(n,t,a)=>{let i=await t(n,a);if("status"in i&&i.status===W){this.isPollingRequest=!0;try{return await this.execLongPolling(i.headers.location)}catch(r){const d=r.response?r.response.data:void 0;if(X(d))i=await this.httpClientApi.get(d.location),"data"in i&&this.notify(m.POLLING_HALTED_OR_DELAYED,i.data.taskStatus);else throw r}}return i});o(this,"cancel",()=>{this.isCancelled=!0});o(this,"start",async n=>{this.notify(m.REQUEST_STARTED);try{const t=await this.execute(this.path,this.restMethod,n);if(this.isCancelled)throw new Error(E);const a=t!==null&&"data"in t?t.data:void 0;return this.notify(m.REQUEST_FINISHED,a,this.isPollingRequest),a?{payload:a}:{payload:void 0}}catch(t){const{response:a}=t;if(a&&a.status===401&&a.headers&&a.headers.location){const i=encodeURIComponent(window.location.pathname+window.location.search);window.location.href=`${a.headers.location}?redirectTo=${i}`}throw(t==null?void 0:t.message)!==E&&new z(this.notify,this.isPollingRequest).handleError(t),t}});this.httpClientApi=n,this.restMethod=t,this.path=a,this.config=i,this.maxPollingLimit=i.maxPollingLimit||this.maxPollingLimit}}const S={updateTriggers:[],keepData:!1,suspendRequest:!1,isCachingOn:!1},y={state:c.NOT_STARTED,error:void 0,data:void 0},se=e=>function(t,a,i=S){const r={...S,...i},[d,l]=s.useState(y);return s.useEffect(()=>{e.hasPath(t.name)&&!r.suspendRequest?(l(u=>({state:c.LOADING,error:void 0,data:r.keepData?u.data:void 0})),e.startRequest(t.name,a,i.isCachingOn).then(u=>{l({state:c.SUCCESS,data:u.payload,error:void 0})}).catch(u=>{(u==null?void 0:u.message)!==E&&l({state:c.ERROR,data:void 0,error:u})})):e.hasPath(t.name)||l(y)},[...r.updateTriggers]),!e.hasPath(t.name)&&r.suspendRequest?y:d};try{useRestApi.displayName="useRestApi",useRestApi.__docgenInfo={description:`Hook som utfører et restkall ved mount. En kan i tillegg legge ved en dependencies-liste som kan trigge ny henting når data
blir oppdatert. Hook returnerer rest-kallets status/resultat/feil`,displayName:"useRestApi",props:{httpClientApi:{defaultValue:null,description:"",name:"httpClientApi",required:!0,type:{name:"HttpClientApi"}},endpointConfigList:{defaultValue:null,description:"",name:"endpointConfigList",required:!0,type:{name:"RequestConfig[]"}},links:{defaultValue:null,description:"",name:"links",required:!0,type:{name:"{ [key: string]: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[]; }"}},notificationMapper:{defaultValue:null,description:"",name:"notificationMapper",required:!0,type:{name:"NotificationMapper"}},cache:{defaultValue:null,description:"",name:"cache",required:!0,type:{name:"ResponseCache"}},activeRunners:{defaultValue:null,description:"",name:"activeRunners",required:!0,type:{name:"Record<string, RequestRunner>"}},doCaching:{defaultValue:null,description:"",name:"doCaching",required:!0,type:{name:"(endpointName: string) => Promise<any>"}},findLinks:{defaultValue:null,description:"",name:"findLinks",required:!0,type:{name:"(rel?: string | undefined) => Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }> | undefined"}},cancelRequest:{defaultValue:null,description:"",name:"cancelRequest",required:!0,type:{name:"(endpointName: string) => void"}},startRequest:{defaultValue:null,description:"",name:"startRequest",required:!0,type:{name:"<T, P>(endpointName: string, params?: P | undefined, isCachingOn?: boolean) => Promise<{ payload: T; }>"}},hasPath:{defaultValue:null,description:"",name:"hasPath",required:!0,type:{name:"(endpointName: string) => boolean"}},setLinks:{defaultValue:null,description:"",name:"setLinks",required:!0,type:{name:"(links: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[], linkCategory?: string) => void"}},resetLinks:{defaultValue:null,description:"",name:"resetLinks",required:!0,type:{name:"() => void"}},setRequestPendingHandler:{defaultValue:null,description:"",name:"setRequestPendingHandler",required:!0,type:{name:"(requestPendingHandler: (message?: string | undefined) => void) => void"}},setAddErrorMessageHandler:{defaultValue:null,description:"",name:"setAddErrorMessageHandler",required:!0,type:{name:"(addErrorMessage: (message: string) => void) => void"}},resetCache:{defaultValue:null,description:"",name:"resetCache",required:!0,type:{name:"() => void"}},getAxios:{defaultValue:null,description:"",name:"getAxios",required:!0,type:{name:"() => AxiosInstance"}},getUrl:{defaultValue:null,description:"",name:"getUrl",required:!0,type:{name:"(endpointName: string) => string | undefined"}},getRestType:{defaultValue:null,description:"",name:"getRestType",required:!0,type:{name:"(endpointName: string) => string"}}}}}catch{}const K=(e,n)=>!(e.length===n.length&&e.every((t,a)=>t===n[a])),ee=e=>e.toLowerCase().replace(/_([a-z])/g,n=>n.toUpperCase()).replace(/_/g,""),v={updateTriggers:[],keepData:!1,suspendRequest:!1,isCachingOn:!1},h={state:c.NOT_STARTED,error:void 0,data:void 0},de=e=>function(t,a=v){const[i,r]=s.useState(h),d={...v,...a},l=s.useRef();s.useEffect(()=>{l.current=d.updateTriggers},[a.updateTriggers]);const u=l.current;return s.useEffect(()=>{if(d.suspendRequest)r(h);else{r(g=>({state:c.LOADING,error:void 0,data:d.keepData?g.data:void 0}));const p=t.filter(g=>e.hasPath(g.key.name));Promise.all(p.map(g=>e.startRequest(g.key.name,g.params,a.isCachingOn))).then(g=>{r({state:c.SUCCESS,data:g.reduce((M,G,x)=>({...M,[ee(p[x].key.name)]:G.payload}),{}),error:void 0})}).catch(g=>{r({state:c.ERROR,data:void 0,error:g})})}},[...d.updateTriggers]),u&&K(u,d.updateTriggers)?{...h,data:a.keepData?i.data:void 0}:i};try{useMultipleRestApi.displayName="useMultipleRestApi",useMultipleRestApi.__docgenInfo={description:`Hook som utfører et restkall ved mount. En kan i tillegg legge ved en dependencies-liste som kan trigge ny henting når data
blir oppdatert. Hook returnerer rest-kallets status/resultat/feil`,displayName:"useMultipleRestApi",props:{httpClientApi:{defaultValue:null,description:"",name:"httpClientApi",required:!0,type:{name:"HttpClientApi"}},endpointConfigList:{defaultValue:null,description:"",name:"endpointConfigList",required:!0,type:{name:"RequestConfig[]"}},links:{defaultValue:null,description:"",name:"links",required:!0,type:{name:"{ [key: string]: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[]; }"}},notificationMapper:{defaultValue:null,description:"",name:"notificationMapper",required:!0,type:{name:"NotificationMapper"}},cache:{defaultValue:null,description:"",name:"cache",required:!0,type:{name:"ResponseCache"}},activeRunners:{defaultValue:null,description:"",name:"activeRunners",required:!0,type:{name:"Record<string, RequestRunner>"}},doCaching:{defaultValue:null,description:"",name:"doCaching",required:!0,type:{name:"(endpointName: string) => Promise<any>"}},findLinks:{defaultValue:null,description:"",name:"findLinks",required:!0,type:{name:"(rel?: string | undefined) => Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }> | undefined"}},cancelRequest:{defaultValue:null,description:"",name:"cancelRequest",required:!0,type:{name:"(endpointName: string) => void"}},startRequest:{defaultValue:null,description:"",name:"startRequest",required:!0,type:{name:"<T, P>(endpointName: string, params?: P | undefined, isCachingOn?: boolean) => Promise<{ payload: T; }>"}},hasPath:{defaultValue:null,description:"",name:"hasPath",required:!0,type:{name:"(endpointName: string) => boolean"}},setLinks:{defaultValue:null,description:"",name:"setLinks",required:!0,type:{name:"(links: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[], linkCategory?: string) => void"}},resetLinks:{defaultValue:null,description:"",name:"resetLinks",required:!0,type:{name:"() => void"}},setRequestPendingHandler:{defaultValue:null,description:"",name:"setRequestPendingHandler",required:!0,type:{name:"(requestPendingHandler: (message?: string | undefined) => void) => void"}},setAddErrorMessageHandler:{defaultValue:null,description:"",name:"setAddErrorMessageHandler",required:!0,type:{name:"(addErrorMessage: (message: string) => void) => void"}},resetCache:{defaultValue:null,description:"",name:"resetCache",required:!0,type:{name:"() => void"}},getAxios:{defaultValue:null,description:"",name:"getAxios",required:!0,type:{name:"() => AxiosInstance"}},getUrl:{defaultValue:null,description:"",name:"getUrl",required:!0,type:{name:"(endpointName: string) => string | undefined"}},getRestType:{defaultValue:null,description:"",name:"getRestType",required:!0,type:{name:"(endpointName: string) => string"}}}}}catch{}const _={state:c.NOT_STARTED,error:void 0,data:void 0},oe=e=>function(t){const[a,i]=s.useState(_),r=s.useCallback((l,u=!1)=>e.hasPath(t.name)?(i(p=>({state:c.LOADING,data:u?p.data:void 0,error:void 0})),e.startRequest(t.name,l).then(p=>(i({state:c.SUCCESS,data:p.payload,error:void 0}),Promise.resolve(p.payload))).catch(p=>{if((p==null?void 0:p.message)!==E)throw i({state:c.ERROR,data:void 0,error:p}),p})):(i(_),Promise.resolve(void 0)),[]),d=s.useCallback(()=>{i(_)},[]);return{startRequest:r,resetRequestData:d,...a}};try{useRestApiRunner.displayName="useRestApiRunner",useRestApiRunner.__docgenInfo={description:"Hook som gir deg ein funksjon til å starte restkall, i tillegg til kallets status/resultat/feil",displayName:"useRestApiRunner",props:{httpClientApi:{defaultValue:null,description:"",name:"httpClientApi",required:!0,type:{name:"HttpClientApi"}},endpointConfigList:{defaultValue:null,description:"",name:"endpointConfigList",required:!0,type:{name:"RequestConfig[]"}},links:{defaultValue:null,description:"",name:"links",required:!0,type:{name:"{ [key: string]: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[]; }"}},notificationMapper:{defaultValue:null,description:"",name:"notificationMapper",required:!0,type:{name:"NotificationMapper"}},cache:{defaultValue:null,description:"",name:"cache",required:!0,type:{name:"ResponseCache"}},activeRunners:{defaultValue:null,description:"",name:"activeRunners",required:!0,type:{name:"Record<string, RequestRunner>"}},doCaching:{defaultValue:null,description:"",name:"doCaching",required:!0,type:{name:"(endpointName: string) => Promise<any>"}},findLinks:{defaultValue:null,description:"",name:"findLinks",required:!0,type:{name:"(rel?: string | undefined) => Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }> | undefined"}},cancelRequest:{defaultValue:null,description:"",name:"cancelRequest",required:!0,type:{name:"(endpointName: string) => void"}},startRequest:{defaultValue:null,description:"",name:"startRequest",required:!0,type:{name:"<T, P>(endpointName: string, params?: P | undefined, isCachingOn?: boolean) => Promise<{ payload: T; }>"}},hasPath:{defaultValue:null,description:"",name:"hasPath",required:!0,type:{name:"(endpointName: string) => boolean"}},setLinks:{defaultValue:null,description:"",name:"setLinks",required:!0,type:{name:"(links: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[], linkCategory?: string) => void"}},resetLinks:{defaultValue:null,description:"",name:"resetLinks",required:!0,type:{name:"() => void"}},setRequestPendingHandler:{defaultValue:null,description:"",name:"setRequestPendingHandler",required:!0,type:{name:"(requestPendingHandler: (message?: string | undefined) => void) => void"}},setAddErrorMessageHandler:{defaultValue:null,description:"",name:"setAddErrorMessageHandler",required:!0,type:{name:"(addErrorMessage: (message: string) => void) => void"}},resetCache:{defaultValue:null,description:"",name:"resetCache",required:!0,type:{name:"() => void"}},getAxios:{defaultValue:null,description:"",name:"getAxios",required:!0,type:{name:"() => AxiosInstance"}},getUrl:{defaultValue:null,description:"",name:"getUrl",required:!0,type:{name:"(endpointName: string) => string | undefined"}},getRestType:{defaultValue:null,description:"",name:"getRestType",required:!0,type:{name:"(endpointName: string) => string"}}}}}catch{}const C={updateTriggers:[],suspendRequest:!1},ue=e=>function(t,a,i=C){const r={...C,...i},[d,l]=s.useState({state:c.NOT_STARTED,error:void 0,data:void 0}),u=s.useContext(V);return s.useEffect(()=>{u&&e.hasPath(t.name)&&!r.suspendRequest&&(u({type:"remove",key:t.name}),l({state:c.LOADING,error:void 0,data:void 0}),e.startRequest(t.name,a).then(p=>{u({type:"success",key:t.name,data:p.payload}),l({state:c.SUCCESS,data:p.payload,error:void 0})}).catch(p=>{l({state:c.ERROR,data:void 0,error:p})}))},r.updateTriggers),d};try{useGlobalStateRestApi.displayName="useGlobalStateRestApi",useGlobalStateRestApi.__docgenInfo={description:"Hook som henter data fra backend og deretter lagrer i",displayName:"useGlobalStateRestApi",props:{httpClientApi:{defaultValue:null,description:"",name:"httpClientApi",required:!0,type:{name:"HttpClientApi"}},endpointConfigList:{defaultValue:null,description:"",name:"endpointConfigList",required:!0,type:{name:"RequestConfig[]"}},links:{defaultValue:null,description:"",name:"links",required:!0,type:{name:"{ [key: string]: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[]; }"}},notificationMapper:{defaultValue:null,description:"",name:"notificationMapper",required:!0,type:{name:"NotificationMapper"}},cache:{defaultValue:null,description:"",name:"cache",required:!0,type:{name:"ResponseCache"}},activeRunners:{defaultValue:null,description:"",name:"activeRunners",required:!0,type:{name:"Record<string, RequestRunner>"}},doCaching:{defaultValue:null,description:"",name:"doCaching",required:!0,type:{name:"(endpointName: string) => Promise<any>"}},findLinks:{defaultValue:null,description:"",name:"findLinks",required:!0,type:{name:"(rel?: string | undefined) => Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }> | undefined"}},cancelRequest:{defaultValue:null,description:"",name:"cancelRequest",required:!0,type:{name:"(endpointName: string) => void"}},startRequest:{defaultValue:null,description:"",name:"startRequest",required:!0,type:{name:"<T, P>(endpointName: string, params?: P | undefined, isCachingOn?: boolean) => Promise<{ payload: T; }>"}},hasPath:{defaultValue:null,description:"",name:"hasPath",required:!0,type:{name:"(endpointName: string) => boolean"}},setLinks:{defaultValue:null,description:"",name:"setLinks",required:!0,type:{name:"(links: Readonly<{ href: string; rel: string; requestPayload?: any; type: string; }>[], linkCategory?: string) => void"}},resetLinks:{defaultValue:null,description:"",name:"resetLinks",required:!0,type:{name:"() => void"}},setRequestPendingHandler:{defaultValue:null,description:"",name:"setRequestPendingHandler",required:!0,type:{name:"(requestPendingHandler: (message?: string | undefined) => void) => void"}},setAddErrorMessageHandler:{defaultValue:null,description:"",name:"setAddErrorMessageHandler",required:!0,type:{name:"(addErrorMessage: (message: string) => void) => void"}},resetCache:{defaultValue:null,description:"",name:"resetCache",required:!0,type:{name:"() => void"}},getAxios:{defaultValue:null,description:"",name:"getAxios",required:!0,type:{name:"() => AxiosInstance"}},getUrl:{defaultValue:null,description:"",name:"getUrl",required:!0,type:{name:"(endpointName: string) => string | undefined"}},getRestType:{defaultValue:null,description:"",name:"getRestType",required:!0,type:{name:"(endpointName: string) => string"}}}}}catch{}function k(e){return s.useContext(O)[e.name]}try{k.displayName="useGlobalStateRestApiData",k.__docgenInfo={description:`Hook som bruker respons som allerede er hentet fra backend. For å kunne bruke denne
må`,displayName:"useGlobalStateRestApiData",props:{name:{defaultValue:null,description:"",name:"name",required:!0,type:{name:"string"}},data:{defaultValue:null,description:"",name:"data",required:!0,type:{name:"T"}},params:{defaultValue:null,description:"",name:"params",required:!0,type:{name:"P"}}}}}catch{}export{R as A,m as E,c as R,H as T,re as a,de as b,oe as c,ue as d,N as e,ie as f,se as g,w as h,j as i,L as j,q as k,A as l,k as u};
//# sourceMappingURL=useGlobalStateRestApiData-37e6cdea.js.map
