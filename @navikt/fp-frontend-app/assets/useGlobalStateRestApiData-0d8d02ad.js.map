{"version":3,"file":"useGlobalStateRestApiData-0d8d02ad.js","sources":["../../../../packages/rest-api-hooks/src/RestApiState.ts","../../../../packages/rest-api-hooks/src/global-data/RestApiContext.tsx","../../../../packages/rest-api-hooks/src/error/RestApiErrorContext.tsx","../../../../packages/rest-api-hooks/src/error/useRestApiError.tsx","../../../../packages/rest-api-hooks/src/error/useRestApiErrorDispatcher.tsx","../../../../packages/rest-api/src/requestApi/eventType.ts","../../../../packages/rest-api/src/requestApi/asyncPollingStatus.ts","../../../../packages/rest-api/src/requestApi/error/TimeoutError.ts","../../../../packages/rest-api/src/requestApi/error/ErrorTypes.ts","../../../../packages/rest-api/src/requestApi/error/RequestErrorEventHandler.ts","../../../../packages/rest-api/src/requestApi/RequestRunner.ts","../../../../packages/rest-api-hooks/src/local-data/useRestApi.tsx","../../../../packages/rest-api-hooks/src/local-data/useMultipleRestApi.tsx","../../../../packages/rest-api-hooks/src/local-data/useRestApiRunner.tsx","../../../../packages/rest-api-hooks/src/global-data/useGlobalStateRestApi.tsx","../../../../packages/rest-api-hooks/src/global-data/useGlobalStateRestApiData.tsx"],"sourcesContent":["enum RestApiState {\n  NOT_STARTED = 'NOT_STARTED',\n  LOADING = 'LOADING',\n  SUCCESS = 'SUCCESS',\n  ERROR = 'ERROR',\n}\n\nexport default RestApiState;\n","import React, { createContext, useReducer, FunctionComponent, ReactNode } from 'react';\n\nconst defaultInitialState = {};\n\ntype Action = { type: 'success'; key: string; data: any } | { type: 'remove'; key: string };\ntype Dispatch = (action: Action) => void;\ntype State = { [key: string]: any };\n\nexport const RestApiStateContext = createContext<State>(defaultInitialState);\nexport const RestApiDispatchContext = createContext<Dispatch | undefined>(undefined);\n\ninterface OwnProps {\n  children: ReactNode;\n  initialState?: { [key in string]: any };\n}\n\n/**\n * Håndterer state for data som skal hentes fra backend kun en gang og som en trenger aksess til\n * mange steder i applikasjonen.\n */\nexport const RestApiProvider: FunctionComponent<OwnProps> = ({ children, initialState }): JSX.Element => {\n  const [state, dispatch] = useReducer((oldState: State, action: Action) => {\n    switch (action.type) {\n      case 'success':\n        return {\n          ...oldState,\n          [action.key]: action.data,\n        };\n      case 'remove':\n        return Object.keys(oldState)\n          .filter(key => key !== action.key)\n          .reduce(\n            (acc, key) => ({\n              ...acc,\n              [key]: oldState[key],\n            }),\n            {},\n          );\n      default:\n        throw new Error();\n    }\n  }, initialState || defaultInitialState);\n\n  return (\n    <RestApiStateContext.Provider value={state}>\n      <RestApiDispatchContext.Provider value={dispatch}>{children}</RestApiDispatchContext.Provider>\n    </RestApiStateContext.Provider>\n  );\n};\n","import React, { createContext, useReducer, FunctionComponent, ReactNode } from 'react';\n\nconst defaultInitialState = {\n  errors: [],\n};\n\ntype Action = { type: 'add'; data: any } | { type: 'remove' };\ntype Dispatch = (action: Action) => void;\ntype State = { errors: any[] };\n\nexport const RestApiErrorStateContext = createContext<State>(defaultInitialState);\nexport const RestApiErrorDispatchContext = createContext<Dispatch | undefined>(undefined);\n\ninterface OwnProps {\n  children: ReactNode;\n  initialState?: State;\n}\n\n/**\n * Tilbyr kontekst for lagring av feilmeldinger.\n */\nexport const RestApiErrorProvider: FunctionComponent<OwnProps> = ({ children, initialState }): JSX.Element => {\n  const [state, dispatch] = useReducer((oldState: State, action: Action) => {\n    switch (action.type) {\n      case 'add':\n        return {\n          errors: oldState.errors.concat(action.data),\n        };\n      case 'remove':\n        return defaultInitialState;\n      default:\n        throw new Error();\n    }\n  }, initialState || defaultInitialState);\n\n  return (\n    <RestApiErrorStateContext.Provider value={state}>\n      <RestApiErrorDispatchContext.Provider value={dispatch}>{children}</RestApiErrorDispatchContext.Provider>\n    </RestApiErrorStateContext.Provider>\n  );\n};\n","import { useContext } from 'react';\n\nimport { RestApiErrorStateContext } from './RestApiErrorContext';\n\n/**\n * Hook som henter alle feilmeldinger registrert i kontekst.\n * Fungerer kun i komponenter som har en @see RestApiErrorProvider over seg i komponent-treet.\n */\nconst useRestApiError = () => {\n  const state = useContext(RestApiErrorStateContext);\n  return state.errors;\n};\n\nexport default useRestApiError;\n","import { useContext, useCallback } from 'react';\n\nimport { RestApiErrorDispatchContext } from './RestApiErrorContext';\n\n/**\n * Hook som tilbyr funksjoner for å legge til eller fjerne feil i kontekst.\n * Fungerer kun i komponenter som har en @see RestApiErrorProvider over seg i komponent-treet.\n */\nconst useRestApiErrorDispatcher = () => {\n  const dispatch = useContext(RestApiErrorDispatchContext);\n\n  const addErrorMessage = useCallback((data: any) => {\n    if (dispatch) {\n      dispatch({ type: 'add', data });\n    }\n  }, []);\n  const removeErrorMessages = useCallback(() => {\n    if (dispatch) {\n      dispatch({ type: 'remove' });\n    }\n  }, []);\n\n  return {\n    addErrorMessage,\n    removeErrorMessages,\n  };\n};\n\nexport default useRestApiErrorDispatcher;\n","/**\n * EventType\n *\n * Interne hendelser i en request-prosess. Kan kobles til eksterne hendelser\n * via @see NotificationMapper.\n */\nenum EventType {\n  POLLING_HALTED_OR_DELAYED = 'POLLING_HALTED_OR_DELAYED',\n  POLLING_TIMEOUT = 'POLLING_TIMEOUT',\n  REQUEST_ERROR = 'REQUEST_ERROR',\n  REQUEST_FINISHED = 'REQUEST_FINISHED',\n  REQUEST_FORBIDDEN = 'REQUEST_FORBIDDEN',\n  REQUEST_STARTED = 'REQUEST_STARTED',\n  REQUEST_UNAUTHORIZED = 'REQUEST_UNAUTHORIZED',\n  STATUS_REQUEST_FINISHED = 'STATUS_REQUEST_FINISHED',\n  STATUS_REQUEST_STARTED = 'STATUS_REQUEST_STARTED',\n  UPDATE_POLLING_MESSAGE = 'UPDATE_POLLING_MESSAGE',\n  REQUEST_GATEWAY_TIMEOUT_OR_NOT_FOUND = 'REQUEST_GATEWAY_TIMEOUT_OR_NOT_FOUND',\n}\n\nexport default EventType;\n","/**\n * asyncPollingStatus\n *\n * Statuser for long-polling request-prosess. Er mappet en-til-en mot java-klasse med samme navn.\n */\nenum AsyncPollingStatus {\n  PENDING = 'PENDING',\n  COMPLETE = 'COMPLETE',\n  DELAYED = 'DELAYED',\n  CANCELLED = 'CANCELLED',\n  HALTED = 'HALTED',\n}\n\nexport default AsyncPollingStatus;\n","class TimeoutError extends Error {\n  location: string;\n\n  constructor(location: string) {\n    super('Maximum polling attempts exceeded');\n    this.location = location;\n  }\n}\n\nexport default TimeoutError;\n","import ErrorType from './errorTsType';\n\n/**\n * Feiltyper til differensiering av framvisning i GUI\n * Skal speile FeilType.java en-til-en\n */\nexport enum ErrorTypes {\n  MANGLER_TILGANG_FEIL = 'MANGLER_TILGANG_FEIL',\n  TOMT_RESULTAT_FEIL = 'TOMT_RESULTAT_FEIL',\n  BEHANDLING_ENDRET_FEIL = 'BEHANDLING_ENDRET_FEIL',\n  GENERELL_FEIL = 'GENERELL_FEIL',\n}\n\nexport const handledErrorTypes = [ErrorTypes.MANGLER_TILGANG_FEIL];\n\nexport const getErrorResponseData = (error?: ErrorType): any =>\n  error && error.response && error.response.data ? error.response.data : error;\n\nexport const errorOfType = (errorType: string, error?: ErrorType): boolean =>\n  !!error && getErrorResponseData(error).type === errorType;\n\nexport const isHandledError = (errorType?: string): boolean =>\n  !!errorType && handledErrorTypes.some(het => het === errorType);\n\nconst hasStatusCode =\n  (statusCode: number) =>\n  (errorStatus?: number): boolean =>\n    errorStatus === statusCode;\n\nexport const is401Error = hasStatusCode(401);\n\nexport const is418Error = hasStatusCode(418);\n","import EventType from '../eventType';\nimport ErrorType from './errorTsType';\nimport { isHandledError } from './ErrorTypes';\nimport TimeoutError from './TimeoutError';\nimport { ErrorResponse } from '../ResponseTsType';\n\ntype NotificationEmitter = (eventType: keyof typeof EventType, data?: any, isPollingRequest?: boolean) => void;\n\nconst isString = (value?: any): boolean => typeof value === 'string';\n\nconst isOfTypeBlob = (error: ErrorType): boolean => error && error.config?.responseType === 'blob';\n\nconst blobParser = (blob: any): Promise<string> => {\n  const fileReader = new FileReader();\n\n  return new Promise((resolve, reject) => {\n    fileReader.onerror = () => {\n      fileReader.abort();\n      reject(new Error('Problem parsing blob'));\n    };\n\n    fileReader.onload = () => {\n      if (fileReader.result && !(fileReader.result instanceof ArrayBuffer)) {\n        resolve(fileReader.result);\n      } else {\n        reject(new Error('Problem parsing blob'));\n      }\n    };\n\n    if (blob instanceof Blob) {\n      fileReader.readAsText(blob);\n    }\n  });\n};\n\ninterface FormatedError {\n  data?: string | ErrorResponse;\n  type?: string;\n  status?: number;\n  isForbidden?: boolean;\n  isUnauthorized?: boolean;\n  is418?: boolean;\n  isGatewayTimeoutOrNotFound?: boolean;\n  location?: string;\n}\n\nclass RequestErrorEventHandler {\n  notify: NotificationEmitter;\n\n  isPollingRequest: boolean;\n\n  constructor(notificationEmitter: NotificationEmitter, isPollingRequest: boolean) {\n    this.notify = notificationEmitter;\n    this.isPollingRequest = isPollingRequest;\n  }\n\n  handleError = async (error: ErrorType | TimeoutError): Promise<string | undefined> => {\n    if (error instanceof TimeoutError) {\n      this.notify(EventType.POLLING_TIMEOUT, { location: error.location });\n      return;\n    }\n\n    const formattedError = this.formatError(error);\n\n    if (isOfTypeBlob(error)) {\n      const jsonErrorString = await blobParser(formattedError.data);\n      if (isString(jsonErrorString)) {\n        formattedError.data = JSON.parse(jsonErrorString);\n      }\n    }\n\n    if (formattedError.isGatewayTimeoutOrNotFound) {\n      this.notify(\n        EventType.REQUEST_GATEWAY_TIMEOUT_OR_NOT_FOUND,\n        { location: formattedError.location },\n        this.isPollingRequest,\n      );\n    } else if (formattedError.isUnauthorized) {\n      this.notify(EventType.REQUEST_UNAUTHORIZED, { message: error.message }, this.isPollingRequest);\n    } else if (formattedError.isForbidden) {\n      this.notify(EventType.REQUEST_FORBIDDEN, formattedError.data ? formattedError.data : { message: error.message });\n    } else if (formattedError.is418) {\n      this.notify(EventType.POLLING_HALTED_OR_DELAYED, formattedError.data);\n    } else if (!error.response && error.message) {\n      this.notify(EventType.REQUEST_ERROR, { message: error.message }, this.isPollingRequest);\n    } else if (!isHandledError(formattedError.type)) {\n      this.notify(EventType.REQUEST_ERROR, this.getFormattedData(formattedError.data), this.isPollingRequest);\n    }\n  };\n\n  // eslint-disable-next-line class-methods-use-this\n  getFormattedData = (data?: string | Record<string, any>): string | Record<string, any> | undefined =>\n    isString(data) ? { message: data } : data;\n\n  // eslint-disable-next-line class-methods-use-this\n  findErrorData = (response: { data?: any; status?: number; statusText?: string }): string | ErrorResponse =>\n    response.data ? response.data : response.statusText;\n\n  formatError = (error: ErrorType): FormatedError => {\n    const response = error && error.response ? error.response : undefined;\n    return {\n      data: response ? this.findErrorData(response) : undefined,\n      type: response && response.data ? response.data.type : undefined,\n      status: response ? response.status : undefined,\n      isForbidden: response ? response.status === 403 : undefined,\n      isUnauthorized: response ? response.status === 401 : undefined,\n      is418: response ? response.status === 418 : undefined,\n      isGatewayTimeoutOrNotFound: response ? response.status === 504 || response.status === 404 : undefined,\n      location: response && response.config ? response.config.url : undefined,\n    };\n  };\n}\n\nexport default RequestErrorEventHandler;\n","import { ResponseType } from 'axios';\n\nimport EventType from './eventType';\nimport AsyncPollingStatus from './asyncPollingStatus';\nimport HttpClientApi from '../HttpClientApiTsType';\nimport { Response } from './ResponseTsType';\nimport RequestAdditionalConfig from '../RequestAdditionalConfigTsType';\nimport TimeoutError from './error/TimeoutError';\nimport RequestErrorEventHandler from './error/RequestErrorEventHandler';\n\nconst HTTP_ACCEPTED = 202;\nconst MAX_POLLING_ATTEMPTS = 50;\nexport const REQUEST_POLLING_CANCELLED = 'INTERNAL_CANCELLATION';\n\nconst wait = (ms: number) =>\n  new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n\nconst hasLocationAndStatusDelayedOrHalted = (responseData: any): boolean =>\n  !!responseData?.location &&\n  (responseData.status === AsyncPollingStatus.DELAYED || responseData.status === AsyncPollingStatus.HALTED);\n\ntype Notify = (eventType: keyof typeof EventType, data?: any, isPolling?: boolean) => void;\ntype NotificationEmitter = (eventType: keyof typeof EventType, data?: any) => void;\n\n/**\n * RequestRunner\n *\n * Denne klassen utfører et spesifikt kall mot en URL. Håndterer også \"long-polling\".\n *\n * En starter prosess med run og avbryter med cancel.\n */\nclass RequestRunner {\n  httpClientApi: HttpClientApi;\n\n  restMethod: (url: string, params: any, responseType?: ResponseType) => Promise<Response>;\n\n  path: string;\n\n  config: RequestAdditionalConfig;\n\n  maxPollingLimit: number = MAX_POLLING_ATTEMPTS;\n\n  // eslint-disable-next-line class-methods-use-this\n  notify: Notify = () => undefined;\n\n  isCancelled = false;\n\n  isPollingRequest = false;\n\n  constructor(\n    httpClientApi: HttpClientApi,\n    restMethod: (url: string, params: any, responseType?: ResponseType) => Promise<Response>,\n    path: string,\n    config: RequestAdditionalConfig,\n  ) {\n    this.httpClientApi = httpClientApi;\n    this.restMethod = restMethod;\n    this.path = path;\n    this.config = config;\n\n    this.maxPollingLimit = config.maxPollingLimit || this.maxPollingLimit;\n  }\n\n  setNotificationEmitter = (notificationEmitter: NotificationEmitter): void => {\n    this.notify = notificationEmitter;\n  };\n\n  execLongPolling = async (location?: string, pollingInterval = 0, pollingCounter = 0): Promise<Response | null> => {\n    if (pollingCounter === this.maxPollingLimit) {\n      this.notify(EventType.REQUEST_FINISHED);\n      throw new TimeoutError(location || 'No location');\n    }\n\n    const interval = pollingCounter < 30 ? pollingInterval : pollingInterval + (pollingCounter - 30) * pollingInterval;\n    await wait(interval);\n\n    if (!location || this.isCancelled) {\n      return null;\n    }\n\n    this.notify(EventType.STATUS_REQUEST_STARTED);\n    const statusOrResultResponse = await this.httpClientApi.get(location);\n    this.notify(EventType.STATUS_REQUEST_FINISHED);\n\n    if (!('data' in statusOrResultResponse)) {\n      return statusOrResultResponse;\n    }\n    const responseData = statusOrResultResponse.data;\n    if (responseData && responseData.status === AsyncPollingStatus.PENDING) {\n      const { pollIntervalMillis, message } = responseData;\n      this.notify(EventType.UPDATE_POLLING_MESSAGE, message);\n      return this.execLongPolling(location, pollIntervalMillis, pollingCounter + 1);\n    }\n\n    return statusOrResultResponse;\n  };\n\n  execute = async <P>(\n    path: string,\n    restMethod: (pathArg: string, params?: P) => Promise<Response>,\n    params: P,\n  ): Promise<Response | null> => {\n    let response = await restMethod(path, params);\n    if ('status' in response && response.status === HTTP_ACCEPTED) {\n      this.isPollingRequest = true;\n      try {\n        return await this.execLongPolling(response.headers.location);\n      } catch (error: any) {\n        const responseData = error.response ? error.response.data : undefined;\n        if (hasLocationAndStatusDelayedOrHalted(responseData)) {\n          response = await this.httpClientApi.get(responseData.location);\n          if ('data' in response) {\n            this.notify(EventType.POLLING_HALTED_OR_DELAYED, response.data.taskStatus);\n          }\n        } else {\n          throw error;\n        }\n      }\n    }\n    return response;\n  };\n\n  cancel = (): void => {\n    this.isCancelled = true;\n  };\n\n  start = async <T, P>(params: P): Promise<{ payload: T }> => {\n    this.notify(EventType.REQUEST_STARTED);\n\n    try {\n      const response = await this.execute<P>(this.path, this.restMethod, params);\n      if (this.isCancelled) {\n        throw new Error(REQUEST_POLLING_CANCELLED);\n      }\n\n      const responseData = response !== null && 'data' in response ? response.data : undefined;\n      this.notify(EventType.REQUEST_FINISHED, responseData, this.isPollingRequest);\n      return responseData ? { payload: responseData } : { payload: undefined };\n    } catch (error: any) {\n      const { response } = error;\n      if (response && response.status === 401 && response.headers && response.headers.location) {\n        const currentPath = encodeURIComponent(window.location.pathname + window.location.search);\n        window.location.href = `${response.headers.location}?redirectTo=${currentPath}`;\n      }\n      if (error?.message !== REQUEST_POLLING_CANCELLED) {\n        new RequestErrorEventHandler(this.notify, this.isPollingRequest).handleError(error);\n      }\n      throw error;\n    }\n  };\n}\n\nexport default RequestRunner;\n","import { useState, useEffect, DependencyList } from 'react';\n\nimport { REQUEST_POLLING_CANCELLED, RequestApi, RestKey } from '@navikt/fp-rest-api';\n\nimport RestApiState from '../RestApiState';\n\nexport interface RestApiData<T> {\n  state: RestApiState;\n  error?: Error;\n  data?: T;\n}\n\nexport interface Options {\n  updateTriggers?: DependencyList;\n  keepData?: boolean;\n  suspendRequest?: boolean;\n  isCachingOn?: boolean;\n}\n\nconst defaultOptions = {\n  updateTriggers: [],\n  keepData: false,\n  suspendRequest: false,\n  isCachingOn: false,\n};\n\nconst DEFAULT_STATE = {\n  state: RestApiState.NOT_STARTED,\n  error: undefined,\n  data: undefined,\n};\n\n/**\n * Hook som utfører et restkall ved mount. En kan i tillegg legge ved en dependencies-liste som kan trigge ny henting når data\n * blir oppdatert. Hook returnerer rest-kallets status/resultat/feil\n */\nconst getUseRestApi = (requestApi: RequestApi) =>\n  function useRestApi<T, P>(key: RestKey<T, P>, params?: P, options: Options = defaultOptions): RestApiData<T> {\n    const allOptions = { ...defaultOptions, ...options };\n\n    const [data, setData] = useState<RestApiData<T>>(DEFAULT_STATE);\n\n    useEffect(() => {\n      if (requestApi.hasPath(key.name) && !allOptions.suspendRequest) {\n        setData(oldState => ({\n          state: RestApiState.LOADING,\n          error: undefined,\n          data: allOptions.keepData ? oldState.data : undefined,\n        }));\n\n        requestApi\n          .startRequest<T, P>(key.name, params, options.isCachingOn)\n          .then(dataRes => {\n            setData({\n              state: RestApiState.SUCCESS,\n              data: dataRes.payload,\n              error: undefined,\n            });\n          })\n          .catch(error => {\n            if (error?.message !== REQUEST_POLLING_CANCELLED) {\n              setData({\n                state: RestApiState.ERROR,\n                data: undefined,\n                error,\n              });\n            }\n          });\n      } else if (!requestApi.hasPath(key.name)) {\n        setData(DEFAULT_STATE);\n      }\n    }, [...allOptions.updateTriggers]);\n\n    if (!requestApi.hasPath(key.name) && allOptions.suspendRequest) {\n      return DEFAULT_STATE;\n    }\n    return data;\n  };\n\nexport default getUseRestApi;\n","import { useState, useEffect, DependencyList, useRef } from 'react';\n\nimport { RequestApi, RestKey } from '@navikt/fp-rest-api';\n\nimport RestApiState from '../RestApiState';\n\nconst notEqual = (array1: DependencyList, array2: DependencyList) =>\n  !(array1.length === array2.length && array1.every((value, index) => value === array2[index]));\nconst format = (name: string): string =>\n  name\n    .toLowerCase()\n    .replace(/_([a-z])/g, m => m.toUpperCase())\n    .replace(/_/g, '');\n\nexport interface RestApiData<T> {\n  state: RestApiState;\n  error?: Error;\n  data?: T;\n}\n\nexport interface EndpointData {\n  key: RestKey<any, any>;\n  params?: any;\n}\n\nexport interface Options {\n  updateTriggers?: DependencyList;\n  keepData?: boolean;\n  suspendRequest?: boolean;\n  isCachingOn?: boolean;\n}\n\nconst defaultOptions = {\n  updateTriggers: [],\n  keepData: false,\n  suspendRequest: false,\n  isCachingOn: false,\n};\n\nconst DEFAULT_STATE = {\n  state: RestApiState.NOT_STARTED,\n  error: undefined,\n  data: undefined,\n};\n\n/**\n * Hook som utfører et restkall ved mount. En kan i tillegg legge ved en dependencies-liste som kan trigge ny henting når data\n * blir oppdatert. Hook returnerer rest-kallets status/resultat/feil\n */\nconst getUseMultipleRestApi = (requestApi: RequestApi) =>\n  function useMultipleRestApi<T, P>(endpoints: EndpointData[], options: Options = defaultOptions): RestApiData<T> {\n    const [data, setData] = useState<RestApiData<T>>(DEFAULT_STATE);\n\n    const allOptions = { ...defaultOptions, ...options };\n\n    const ref = useRef<DependencyList>();\n    useEffect(() => {\n      ref.current = allOptions.updateTriggers;\n    }, [options.updateTriggers]);\n    const previousTriggers = ref.current;\n\n    useEffect(() => {\n      if (!allOptions.suspendRequest) {\n        setData(oldState => ({\n          state: RestApiState.LOADING,\n          error: undefined,\n          data: allOptions.keepData ? oldState.data : undefined,\n        }));\n\n        const filteredEndpoints = endpoints.filter(e => requestApi.hasPath(e.key.name));\n\n        Promise.all(\n          filteredEndpoints.map(e => requestApi.startRequest<T, P>(e.key.name, e.params, options.isCachingOn)),\n        )\n          .then(dataRes => {\n            setData({\n              state: RestApiState.SUCCESS,\n              data: dataRes.reduce(\n                (acc, result, index) => ({\n                  ...acc,\n                  [format(filteredEndpoints[index].key.name)]: result.payload,\n                }),\n                {} as T,\n              ),\n              error: undefined,\n            });\n          })\n          .catch(error => {\n            setData({\n              state: RestApiState.ERROR,\n              data: undefined,\n              error,\n            });\n          });\n      } else {\n        setData(DEFAULT_STATE);\n      }\n    }, [...allOptions.updateTriggers]);\n\n    return previousTriggers && notEqual(previousTriggers, allOptions.updateTriggers)\n      ? { ...DEFAULT_STATE, data: options.keepData ? data.data : undefined }\n      : data;\n  };\n\nexport default getUseMultipleRestApi;\n","import { useState, useCallback } from 'react';\n\nimport { REQUEST_POLLING_CANCELLED, ErrorType, RequestApi, RestKey } from '@navikt/fp-rest-api';\n\nimport RestApiState from '../RestApiState';\n\nexport type RestApiData<T> = {\n  state: RestApiState;\n  error?: ErrorType;\n  data?: T;\n};\n\nexport type RunnerOutput<T, P> = {\n  startRequest: (params?: P, keepData?: boolean) => Promise<T | undefined>;\n  resetRequestData: () => void;\n} & RestApiData<T>;\n\nconst DEFAULT_STATE = {\n  state: RestApiState.NOT_STARTED,\n  error: undefined,\n  data: undefined,\n};\n\n/**\n * Hook som gir deg ein funksjon til å starte restkall, i tillegg til kallets status/resultat/feil\n */\nconst getUseRestApiRunner = (requestApi: RequestApi) =>\n  function useRestApiRunner<T, P>(key: RestKey<T, P>): RunnerOutput<T, P> {\n    const [data, setData] = useState<RestApiData<T>>(DEFAULT_STATE);\n\n    const startRequest = useCallback((params?: P, keepData = false): Promise<T | undefined> => {\n      if (requestApi.hasPath(key.name)) {\n        setData(oldState => ({\n          state: RestApiState.LOADING,\n          data: keepData ? oldState.data : undefined,\n          error: undefined,\n        }));\n\n        return requestApi\n          .startRequest<T, P>(key.name, params)\n          .then(dataRes => {\n            setData({\n              state: RestApiState.SUCCESS,\n              data: dataRes.payload,\n              error: undefined,\n            });\n            return Promise.resolve(dataRes.payload);\n          })\n          .catch(error => {\n            if (error?.message !== REQUEST_POLLING_CANCELLED) {\n              setData({\n                state: RestApiState.ERROR,\n                data: undefined,\n                error,\n              });\n              throw error;\n            }\n            return undefined;\n          });\n      }\n      setData(DEFAULT_STATE);\n      return Promise.resolve(undefined);\n    }, []);\n\n    const resetRequestData = useCallback(() => {\n      setData(DEFAULT_STATE);\n    }, []);\n\n    return {\n      startRequest,\n      resetRequestData,\n      ...data,\n    };\n  };\n\nexport default getUseRestApiRunner;\n","import { useState, useEffect, useContext, DependencyList } from 'react';\n\nimport { RequestApi, RestKey } from '@navikt/fp-rest-api';\n\nimport { RestApiDispatchContext } from './RestApiContext';\nimport RestApiState from '../RestApiState';\n\nexport interface RestApiData<T> {\n  state: RestApiState;\n  error?: Error;\n  data?: T;\n}\n\nexport interface Options {\n  updateTriggers?: DependencyList;\n  suspendRequest?: boolean;\n}\n\nconst defaultOptions = {\n  updateTriggers: [],\n  suspendRequest: false,\n};\n\n/**\n * Hook som henter data fra backend og deretter lagrer i @see RestApiContext\n */\nconst getUseGlobalStateRestApi = (requestApi: RequestApi) =>\n  function useGlobalStateRestApi<T, P>(\n    key: RestKey<T, P>,\n    params?: P,\n    options: Options = defaultOptions,\n  ): RestApiData<T> {\n    const allOptions = { ...defaultOptions, ...options };\n\n    const [data, setData] = useState<RestApiData<T>>({\n      state: RestApiState.NOT_STARTED,\n      error: undefined,\n      data: undefined,\n    });\n\n    const dispatch = useContext(RestApiDispatchContext);\n\n    useEffect(() => {\n      if (dispatch && requestApi.hasPath(key.name) && !allOptions.suspendRequest) {\n        dispatch({ type: 'remove', key: key.name });\n\n        setData({\n          state: RestApiState.LOADING,\n          error: undefined,\n          data: undefined,\n        });\n\n        requestApi\n          .startRequest<T, P>(key.name, params)\n          .then((dataRes: { payload: T }) => {\n            dispatch({ type: 'success', key: key.name, data: dataRes.payload });\n            setData({\n              state: RestApiState.SUCCESS,\n              data: dataRes.payload,\n              error: undefined,\n            });\n          })\n          .catch(error => {\n            setData({\n              state: RestApiState.ERROR,\n              data: undefined,\n              error,\n            });\n          });\n      }\n    }, allOptions.updateTriggers);\n\n    return data;\n  };\n\nexport default getUseGlobalStateRestApi;\n","import { useContext } from 'react';\n\nimport { RestKey } from '@navikt/fp-rest-api';\n\nimport { RestApiStateContext } from './RestApiContext';\n\n/**\n * Hook som bruker respons som allerede er hentet fra backend. For å kunne bruke denne\n * må @see useGlobalStateRestApi først brukes for å hente data fra backend\n */\nfunction useGlobalStateRestApiData<T, P>(key: RestKey<T, P>): T {\n  const state = useContext(RestApiStateContext);\n  return state[key.name];\n}\n\nexport default useGlobalStateRestApiData;\n"],"names":["RestApiState","defaultInitialState","RestApiStateContext","createContext","RestApiDispatchContext","RestApiProvider","children","initialState","state","dispatch","useReducer","oldState","action","key","acc","jsx","RestApiErrorStateContext","RestApiErrorDispatchContext","RestApiErrorProvider","useRestApiError","useContext","useRestApiErrorDispatcher","addErrorMessage","useCallback","data","removeErrorMessages","EventType","AsyncPollingStatus","TimeoutError","location","__publicField","ErrorTypes","handledErrorTypes","getErrorResponseData","error","errorOfType","errorType","isHandledError","het","isString","value","isOfTypeBlob","_a","blobParser","blob","fileReader","resolve","reject","RequestErrorEventHandler","notificationEmitter","isPollingRequest","formattedError","jsonErrorString","response","HTTP_ACCEPTED","MAX_POLLING_ATTEMPTS","REQUEST_POLLING_CANCELLED","wait","ms","hasLocationAndStatusDelayedOrHalted","responseData","RequestRunner","httpClientApi","restMethod","path","config","pollingInterval","pollingCounter","interval","statusOrResultResponse","pollIntervalMillis","message","params","currentPath","defaultOptions","DEFAULT_STATE","getUseRestApi","requestApi","options","allOptions","setData","useState","useEffect","dataRes","notEqual","array1","array2","index","format","name","m","getUseMultipleRestApi","endpoints","ref","useRef","previousTriggers","filteredEndpoints","e","result","getUseRestApiRunner","startRequest","keepData","resetRequestData","getUseGlobalStateRestApi","useGlobalStateRestApiData"],"mappings":"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"}